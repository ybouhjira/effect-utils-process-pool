{"version":3,"sources":["../src/errors.ts","../src/ProcessPool.ts","../src/ManagedProcess.ts","../src/ProcessPoolLive.ts"],"names":["Data","Context","Stream","Effect","Layer","Ref","HashMap","Schedule","Duration","spawn"],"mappings":"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","file":"index.cjs","sourcesContent":["import { Data } from 'effect';\n\nexport class ProcessPoolError extends Data.TaggedError('ProcessPoolError')<{\n  readonly message: string;\n  readonly cause?: unknown;\n}> {}\n\nexport class ProcessLimitError extends Data.TaggedError('ProcessLimitError')<{\n  readonly message: string;\n  readonly maxConcurrent: number;\n  readonly currentCount: number;\n}> {}\n\nexport class ProcessNotFoundError extends Data.TaggedError('ProcessNotFoundError')<{\n  readonly message: string;\n  readonly processId: string;\n}> {}\n","import { Context, Effect } from 'effect';\nimport type { ProcessConfig } from './types.js';\nimport type { ManagedProcess } from './ManagedProcess.js';\nimport { ProcessPoolError, ProcessLimitError, ProcessNotFoundError } from './errors.js';\n\nexport interface ProcessPoolInterface {\n  readonly spawn: (\n    id: string,\n    config: ProcessConfig\n  ) => Effect.Effect<ManagedProcess, ProcessPoolError | ProcessLimitError>;\n\n  readonly get: (id: string) => Effect.Effect<ManagedProcess, ProcessNotFoundError>;\n\n  readonly kill: (id: string) => Effect.Effect<void, ProcessNotFoundError | ProcessPoolError>;\n\n  readonly interrupt: (id: string) => Effect.Effect<void, ProcessNotFoundError | ProcessPoolError>;\n\n  readonly killAll: () => Effect.Effect<void, ProcessPoolError>;\n\n  readonly size: () => Effect.Effect<number>;\n\n  readonly has: (id: string) => Effect.Effect<boolean>;\n}\n\nexport class ProcessPool extends Context.Tag('ProcessPool')<ProcessPool, ProcessPoolInterface>() {}\n","import { Effect, Stream } from 'effect';\nimport type { ChildProcess } from 'node:child_process';\nimport type { ProcessConfig, ProcessStatus } from './types.js';\nimport { ProcessPoolError } from './errors.js';\n\nexport interface ManagedProcess {\n  readonly id: string;\n  readonly config: ProcessConfig;\n  readonly status: () => ProcessStatus;\n  readonly interrupt: () => Effect.Effect<void, ProcessPoolError>;\n  readonly kill: () => Effect.Effect<void, ProcessPoolError>;\n  readonly stdout: Stream.Stream<string, ProcessPoolError>;\n  readonly stderr: Stream.Stream<string, ProcessPoolError>;\n  readonly write: (data: string) => Effect.Effect<void, ProcessPoolError>;\n}\n\nexport class ManagedProcessImpl implements ManagedProcess {\n  private currentStatus: ProcessStatus = 'starting';\n  readonly stdout: Stream.Stream<string, ProcessPoolError>;\n  readonly stderr: Stream.Stream<string, ProcessPoolError>;\n\n  constructor(\n    public readonly id: string,\n    public readonly config: ProcessConfig,\n    private readonly childProcess: ChildProcess\n  ) {\n    // Listen to process events to update status\n    this.childProcess.on('spawn', () => {\n      this.currentStatus = 'running';\n    });\n\n    this.childProcess.on('exit', (code: number | null, signal: string | null) => {\n      if (signal) {\n        this.currentStatus = 'stopped';\n      } else if (code !== 0) {\n        this.currentStatus = 'error';\n      } else {\n        this.currentStatus = 'stopped';\n      }\n    });\n\n    this.childProcess.on('error', () => {\n      this.currentStatus = 'error';\n    });\n\n    // If process spawned immediately\n    if (this.childProcess.pid) {\n      this.currentStatus = 'running';\n    }\n\n    // Create stdout stream\n    this.stdout = this.createReadableStream(this.childProcess.stdout);\n\n    // Create stderr stream\n    this.stderr = this.createReadableStream(this.childProcess.stderr);\n  }\n\n  private createReadableStream(\n    readable: import('node:stream').Readable | null\n  ): Stream.Stream<string, ProcessPoolError> {\n    /* v8 ignore next 3 - Defensive check, unreachable with stdio: ['pipe', 'pipe', 'pipe'] */\n    if (!readable) {\n      return Stream.empty;\n    }\n\n    const self = this;\n    return Stream.asyncScoped<string, ProcessPoolError>((emit) =>\n      Effect.gen(function* () {\n        const onData = (chunk: Buffer) => {\n          emit.single(chunk.toString('utf-8'));\n        };\n\n        const onEnd = () => {\n          emit.end();\n        };\n\n        /* v8 ignore next 8 - Stream errors are rare, hard to trigger without mocking */\n        const onError = (err: Error) => {\n          emit.fail(\n            new ProcessPoolError({\n              message: `Stream error on process ${self.id}`,\n              cause: err,\n            })\n          );\n        };\n\n        readable.on('data', onData);\n        readable.on('end', onEnd);\n        readable.on('error', onError);\n\n        // Cleanup function\n        yield* Effect.addFinalizer(() =>\n          Effect.sync(() => {\n            readable.off('data', onData);\n            readable.off('end', onEnd);\n            readable.off('error', onError);\n          })\n        );\n      })\n    );\n  }\n\n  status(): ProcessStatus {\n    return this.currentStatus;\n  }\n\n  interrupt(): Effect.Effect<void, ProcessPoolError> {\n    const self = this;\n    return Effect.gen(function* () {\n      if (self.childProcess.pid && !self.childProcess.killed) {\n        self.currentStatus = 'stopping';\n        self.childProcess.kill('SIGINT');\n        // Note: kill() returns false if process already dead, but that's OK (no-op)\n      }\n    });\n  }\n\n  kill(): Effect.Effect<void, ProcessPoolError> {\n    const self = this;\n    return Effect.gen(function* () {\n      if (self.childProcess.pid && !self.childProcess.killed) {\n        self.currentStatus = 'stopping';\n        self.childProcess.kill('SIGTERM');\n        // Note: kill() returns false if process already dead, but that's OK (no-op)\n      }\n    });\n  }\n\n  write(data: string): Effect.Effect<void, ProcessPoolError> {\n    const self = this;\n    return Effect.gen(function* () {\n      /* v8 ignore next 7 - Defensive check, unreachable with stdio: ['pipe', 'pipe', 'pipe'] */\n      if (!self.childProcess.stdin) {\n        return yield* Effect.fail(\n          new ProcessPoolError({\n            message: `No stdin available for process ${self.id}`,\n          })\n        );\n      }\n\n      if (self.childProcess.killed || !self.childProcess.pid) {\n        return yield* Effect.fail(\n          new ProcessPoolError({\n            message: `Cannot write to dead process ${self.id}`,\n          })\n        );\n      }\n\n      yield* Effect.async<void, ProcessPoolError>((resume) => {\n        self.childProcess.stdin!.write(data, (err) => {\n          if (err) {\n            resume(\n              Effect.fail(\n                new ProcessPoolError({\n                  message: `Failed to write to process ${self.id}`,\n                  cause: err,\n                })\n              )\n            );\n          } else {\n            resume(Effect.succeed(undefined));\n          }\n        });\n      });\n    });\n  }\n}\n","import { Layer, Effect, Ref, HashMap, Schedule, Duration } from 'effect';\nimport { spawn } from 'node:child_process';\nimport { ProcessPool } from './ProcessPool.js';\nimport { ManagedProcessImpl } from './ManagedProcess.js';\nimport type { PoolConfig, ProcessConfig } from './types.js';\nimport { ProcessPoolError, ProcessLimitError, ProcessNotFoundError } from './errors.js';\n\nexport const ProcessPoolLive = (config: PoolConfig): Layer.Layer<ProcessPool> =>\n  Layer.scoped(\n    ProcessPool,\n    Effect.gen(function* () {\n      const processes = yield* Ref.make(HashMap.empty<string, ManagedProcessImpl>());\n\n      // Helper: kill all processes\n      const killAllProcesses = Effect.gen(function* () {\n        const current = yield* Ref.get(processes);\n        const allProcesses = Array.from(HashMap.values(current));\n\n        // Kill all processes\n        for (const managed of allProcesses) {\n          yield* managed.kill();\n        }\n\n        // Clear the pool\n        yield* Ref.set(processes, HashMap.empty());\n      });\n\n      // Register finalizer - kills all processes on scope close\n      yield* Effect.addFinalizer(() =>\n        killAllProcesses.pipe(Effect.catchAll(() => Effect.void))\n      );\n\n      // Optional health check\n      if (config.healthCheckInterval) {\n        const healthCheck = Effect.gen(function* () {\n          const current = yield* Ref.get(processes);\n          const entries = Array.from(HashMap.entries(current));\n\n          for (const [id, managed] of entries) {\n            const status = managed.status();\n            /* v8 ignore next 3 - Defensive cleanup, hard to test due to race with exit handler */\n            if (status === 'stopped' || status === 'error') {\n              yield* Ref.update(processes, HashMap.remove(id));\n            }\n          }\n        });\n\n        const scheduled = healthCheck.pipe(\n          Effect.schedule(Schedule.spaced(Duration.decode(config.healthCheckInterval)))\n        );\n\n        // Fork as daemon - will be interrupted when scope closes\n        yield* Effect.forkDaemon(scheduled);\n      }\n\n      return ProcessPool.of({\n        spawn: (id: string, processConfig: ProcessConfig) =>\n          Effect.gen(function* () {\n            const current = yield* Ref.get(processes);\n            const currentSize = HashMap.size(current);\n\n            if (currentSize >= config.maxConcurrent) {\n              return yield* Effect.fail(\n                new ProcessLimitError({\n                  message: `Process pool limit reached. Max: ${config.maxConcurrent}, Current: ${currentSize}`,\n                  maxConcurrent: config.maxConcurrent,\n                  currentCount: currentSize,\n                })\n              );\n            }\n\n            // Spawn child process\n            const child = spawn(\n              processConfig.command,\n              processConfig.args ?? [],\n              {\n                cwd: processConfig.cwd,\n                env: processConfig.env\n                  ? { ...globalThis.process.env, ...processConfig.env }\n                  : undefined,\n                stdio: ['pipe', 'pipe', 'pipe'],\n              }\n            );\n\n            const managed = new ManagedProcessImpl(id, processConfig, child);\n\n            // Wait for process to be ready before proceeding\n            yield* Effect.async<void, ProcessPoolError>((resume) => {\n              if (child.pid) {\n                // Already spawned synchronously\n                resume(Effect.succeed(undefined));\n                return;\n              }\n              child.once('spawn', () => {\n                resume(Effect.succeed(undefined));\n              });\n              child.once('error', (err) => {\n                resume(Effect.fail(new ProcessPoolError({\n                  message: `Failed to spawn process ${id}: ${err.message}`,\n                  cause: err,\n                })));\n              });\n            });\n\n            // Auto-cleanup on exit\n            child.on('exit', () => {\n              Effect.runSync(Ref.update(processes, HashMap.remove(id)));\n            });\n\n            // Add to pool\n            yield* Ref.update(processes, HashMap.set(id, managed));\n\n            return managed;\n          }),\n\n        get: (id: string) =>\n          Effect.gen(function* () {\n            const current = yield* Ref.get(processes);\n            const maybeProcess = HashMap.get(current, id);\n\n            if (maybeProcess._tag === 'None') {\n              return yield* Effect.fail(\n                new ProcessNotFoundError({\n                  message: `Process not found: ${id}`,\n                  processId: id,\n                })\n              );\n            }\n\n            return maybeProcess.value;\n          }),\n\n        kill: (id: string) =>\n          Effect.gen(function* () {\n            const current = yield* Ref.get(processes);\n            const maybeProcess = HashMap.get(current, id);\n\n            if (maybeProcess._tag === 'None') {\n              return yield* Effect.fail(\n                new ProcessNotFoundError({\n                  message: `Process not found: ${id}`,\n                  processId: id,\n                })\n              );\n            }\n\n            const managed = maybeProcess.value;\n\n            // Kill the process\n            yield* managed.kill();\n\n            // Remove from pool immediately\n            yield* Ref.update(processes, HashMap.remove(id));\n          }),\n\n        interrupt: (id: string) =>\n          Effect.gen(function* () {\n            const current = yield* Ref.get(processes);\n            const maybeProcess = HashMap.get(current, id);\n\n            if (maybeProcess._tag === 'None') {\n              return yield* Effect.fail(\n                new ProcessNotFoundError({\n                  message: `Process not found: ${id}`,\n                  processId: id,\n                })\n              );\n            }\n\n            const managed = maybeProcess.value;\n\n            // Interrupt the process\n            yield* managed.interrupt();\n\n            // Remove from pool immediately\n            yield* Ref.update(processes, HashMap.remove(id));\n          }),\n\n        killAll: () => killAllProcesses,\n\n        size: () =>\n          Effect.gen(function* () {\n            const current = yield* Ref.get(processes);\n            return HashMap.size(current);\n          }),\n\n        has: (id: string) =>\n          Effect.gen(function* () {\n            const current = yield* Ref.get(processes);\n            const maybeProcess = HashMap.get(current, id);\n            return maybeProcess._tag === 'Some';\n          }),\n      });\n    })\n  );\n"]}